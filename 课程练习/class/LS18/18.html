<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    // 可以把数组理解为引用型
    var arr1 = ['a', 'b', 'c', 'd'];
    var arr2 = arr1;
    arr1[0] = 'e';
    console.log(arr2);

    var arr3 = [, 2, , 4];
    Array.prototype.min = function() {
        return "最小值";
    }
    console.log(arr3.length);

    for(var i in arr3) {
        console.log(i, arr3[i]);
    }

    // 多维数组
    var table = new Array(5);
    for(var i = 0; i < table.length; i++) {
        table[i] = new Array(5);
    }
    for(var row = 0; row < table.length; row++) {
        for(var col = 0; col < table[row].length; col++) {
            table[row][col] = row * col;
        }
    }
    var product = table[2][4];
    console.log(product);

    // 数组的原型方法
    // Array.prototype.reverse();
    console.log(arr2.reverse());

    /*
        1. 判断方法是静态方法还是原型方法
        2. 确定这个方法是用来做什么的
            (1) 是否会对原变量产生影响
            (2) 最终的作用效果是什么样的
        3. 判断方法的参数分别是什么
            (1) 如果参数是回掉函数的形式，判断回调函数的参数是什么
            (2) 如果是值类型参数，判断参数所代表的意义
        4. 确定方法调用的返回值
    */
    var arr4 = [5, 9, 1, 6];
    // console.log(arr4.sort());
    function compareNumbers(a, b) {
        return a - b;
    }
    arr4.sort(compareNumbers);
    console.log(arr4);

    /*
        forEach(callback, thisArg);
        callback(element, index, arr);
            element遍历数组每次取到的数组元素值
            index遍历数组每次取到的数组元素的索引
            arr操作的数组
        thisArg可以指明回调函数内部this的指向
    */
    var arrr = ['a', 'b', 'c', 'd'];
    arrr.forEach(function(element, index, arrr1) {
        console.log(element, index, arrr1);
        window.x = 10;
    }, window)

    arr5 = [1, 2, 3];
    var arr6 = arr5.map(function(element) {
        return element * 2;
    })
    console.log(arr6);
</script>
</html>